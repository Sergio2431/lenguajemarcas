<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Chapter&nbsp;11.&nbsp;General XQuery extension functions</title><link rel="stylesheet" href="html.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.73.1"><link rel="start" href="index.html" title="Qizx Manual"><link rel="up" href="reference.html" title="Part&nbsp;IV.&nbsp;Reference"><link rel="prev" href="reference.html" title="Part&nbsp;IV.&nbsp;Reference"><link rel="next" href="fulltext_extensions.html" title="Chapter&nbsp;12.&nbsp;Full-text XQuery extension functions"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Chapter&nbsp;11.&nbsp;General XQuery extension functions</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="reference.html">Prev</a>&nbsp;</td><th width="60%" align="center">Part&nbsp;IV.&nbsp;Reference</th><td width="20%" align="right">&nbsp;<a accesskey="n" href="fulltext_extensions.html">Next</a></td></tr></table><hr></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="general_extensions"></a>Chapter&nbsp;11.&nbsp;General XQuery extension functions</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="general_extensions.html#d0e8870">1. Serialization</a></span></dt><dt><span class="sect1"><a href="general_extensions.html#d0e9055">2. XSL Transformation</a></span></dt><dt><span class="sect1"><a href="general_extensions.html#d0e9195">3. Dynamic evaluation</a></span></dt><dt><span class="sect1"><a href="general_extensions.html#d0e9240">4. Pattern-matching</a></span></dt><dt><span class="sect1"><a href="general_extensions.html#d0e9329">5. Date and Time</a></span></dt><dd><dl><dt><span class="sect2"><a href="general_extensions.html#d0e9332">5.1. Differences with W3C specifications</a></span></dt><dt><span class="sect2"><a href="general_extensions.html#d0e9337">5.2. Cast Extensions</a></span></dt><dt><span class="sect2"><a href="general_extensions.html#d0e9398">5.3. Additional constructors</a></span></dt><dt><span class="sect2"><a href="general_extensions.html#d0e9483">5.4. Additional accessors</a></span></dt></dl></dd><dt><span class="sect1"><a href="general_extensions.html#d0e9663">6. Error handling</a></span></dt><dt><span class="sect1"><a href="general_extensions.html#d0e9730">7. Miscellaneous</a></span></dt></dl></div><p>These general purpose functions belong to the namespace denoted by the predefined "<code class="literal">x:</code>" prefix. The <code class="literal">x:</code> prefix refers to namespace "<code class="literal">com.qizx.functions.ext</code>".</p><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e8870"></a>1.&nbsp;Serialization</h2></div></div></div><p><em class="glossterm">Serialization</em> &#8212; the process of converting XML nodes into a stream of characters &#8212; is defined in the W3C specifications, however there is no standard function for performing serialization.</p><p><code class="function">x:serialize</code> can output a document or a node into XML, HTML, XHTML or plain text, to a file or to the default output stream.</p><div class="variablelist"><dl><dt><span class="term"><pre class="synopsis">x:serialize( <em class="replaceable"><code>$node</code></em> as node(), <em class="replaceable"><code>$options</code></em> as element(option) )
  as xs:string?</pre></span></dt><dd><p><b>Description:&nbsp;</b>Serializes the element and all its content into text. The output can be a file (see options below).</p><p><b>Parameter <em class="replaceable"><code>$tree</code></em>:&nbsp;</b>a XML tree to be serialized to text.</p><p><b>Parameter <em class="replaceable"><code>$options</code></em>:&nbsp;</b>an element bearing options in the form of attributes: see below.</p><p><b>Returned value:&nbsp;</b>The path of the output file if specified, otherwise the serialized result.</p><p>The options argument (which may be absent) has the form of an element of name "options" whose attributes are used to specify different options. For example:</p><pre class="programlisting">x:serialize( $doc,
             &lt;options output="out\doc.xml"
                      encoding="ISO-8859-1" indent="yes"/&gt;)</pre><p>This mechanism is similar to XSLT's xsl:output specification and is very convenient since the options can be computed or extracted from a XML document.</p><div class="table"><a name="serial_options_table"></a><p class="title"><b>Table&nbsp;11.1.&nbsp;Implemented serialization options</b></p><div class="table-contents"><table summary="Implemented serialization options" border="1"><colgroup><col width="28%" align="left"><col width="29%"><col width="43%"></colgroup><thead><tr><th align="left">option name</th><th align="left">values</th><th align="left">description</th></tr></thead><tbody><tr><td align="left">method</td><td>XML (default) XHTML, HTML, or TEXT</td><td>output method</td></tr><tr><td align="left">output / file</td><td>a file path</td><td>output file. If this option is not specified, the generated text is returned as a string.</td></tr><tr><td align="left">version</td><td>default "1.0"</td><td>version generated in the XML declaration. No validity check.</td></tr><tr><td align="left">standalone</td><td>"yes" or "no".</td><td>No check is performed.</td></tr><tr><td align="left">encoding</td><td>must be the name of an encoding supported by the JRE.</td><td>The name supplied is generated in the XML declaration. If different than UTF-8, it forces the output of the XML declaration.</td></tr><tr><td align="left">indent</td><td>"yes" or "no" (default "no").</td><td>output indented.</td></tr><tr><td align="left">indent-value <span class="emphasis"><em>(extension)</em></span></td><td>integer value</td><td>specifies the number of space characters used for indentation.</td></tr><tr><td align="left">omit-xml-declaration</td><td>"yes" or "no" (default "no").</td><td>controls the output of a XML declaration.</td></tr><tr><td align="left">include-content-type</td><td>"yes" or "no" (default "no").</td><td>for XHTML and HTML methods, if the value is "yes", a META element specifying the content type is added at the beginning of element HEAD.</td></tr><tr><td align="left">escape-uri-attributes</td><td>"yes" or "no" (default "yes").</td><td>for XHTML and HTML methods, escapes <em class="firstterm">URI attributes</em> (i.e specific HTML attributes whose value is an URI).</td></tr><tr><td align="left">doctype-public</td><td>the public ID in the DOCTYPE declaration.</td><td>Triggers the output of the DOCTYPE declaration. Must be used together with the <code class="literal">doctype-system</code> option.</td></tr><tr><td align="left">doctype-system</td><td>the system ID in the DOCTYPE declaration.</td><td>Triggers the output of the DOCTYPE declaration.</td></tr><tr><td align="left">auto-dtd <span class="emphasis"><em>(extension)</em></span></td><td>"yes" or "no" (default "yes").</td><td><p>If the node is a document node and if this document has DTD information, then output a DOCTYPE declaration. </p><div class="itemizedlist"><ul type="disc"><li><p>A Document stored in an XML Library may have properties storing this information (dtd-system-id and dtd-public-id) initially set by import.</p></li><li><p>a parsed document gets DTD information from the XML parser.</p></li><li><p>a constructed node has no DTD information.</p></li></ul></div></td></tr></tbody></table></div></div><br class="table-break"><p>&nbsp;</p></dd></dl></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e9055"></a>2.&nbsp;XSL Transformation</h2></div></div></div><p>The<code class="function"> x:transform</code> function invokes a XSLT style-sheet on a node and can retrieve the results of the transformation as a tree, or let the style-sheet output the results.</p><p>This is a useful feature when one wants to transform a document (for example extracted from the XML Libraries) or a computed fragment of XML into different output formats like HTML, XSL-FO etc.</p><p>This example generates the transformed document <code class="varname">$doc</code> into a file <code class="filename">out\doc.xml</code>:</p><pre class="programlisting">x:transform( $doc, "ssheet1.xsl",
             &lt;parameters param1="one" param2="two"/&gt;,
             &lt;options output-file="out\doc.xml" indent="yes"/&gt;)</pre><p>The next example returns a new document tree. Suppose we have this very simple stylesheet which renames the element "<code class="literal">doc</code>" into "<code class="literal">newdoc</code>":</p><pre class="programlisting">&lt;xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
                 version ="1.0" &gt;
  &lt;xsl:template match="doc"&gt;
     &lt;newdoc&gt;&lt;xsl:apply-templates/&gt;&lt;/newdoc&gt;
  &lt;/xsl:template&gt;
&lt;/xsl:stylesheet&gt;</pre><p>The following XQuery expression:</p><pre class="programlisting">x:transform( &lt;doc&gt;text&lt;/doc&gt;, "ssheet1.xsl", &lt;parameters/&gt; )</pre><p>returns:</p><pre class="programlisting">&lt;newdoc&gt;text&lt;/newdoc&gt;</pre><div class="variablelist"><dl><dt><span class="term"><pre class="synopsis">x:transform( <em class="replaceable"><code>$source</code></em> as node(), 
             <em class="replaceable"><code>$stylesheet-URI</code></em> as xs:string, 
             <em class="replaceable"><code>$xslt-parameters</code></em> as element(parameters) 
             [, <em class="replaceable"><code>$options</code></em> as element(options)] )
  as node()?</pre></span></dt><dd><p>Transforms the source tree through a XSLT stylesheet. If no output file is explicitly specified in the options, the function returns a new tree.</p><p><b>Parameter <em class="replaceable"><code>$source</code></em>:&nbsp;</b>a XML tree to be transformed. It does not need to be a complete document.</p><p><b>Parameter <em class="replaceable"><code>$stylesheet-URI</code></em>:&nbsp;</b>the URI of a XSLT stylesheet. Stylesheets are cached and reused for consecutive transformations.</p><p><b>Parameter <em class="replaceable"><code>$xslt-parameters</code></em>:&nbsp;</b>an element holding parameter values to pass to the XSLT engine. The parameters are specified in the form of attributes. The name of an attribute matches the name of a <code class="sgmltag-element">xsl:param</code> declaration in the stylesheet (namespaces can be used). The value of the attribute is passed to the XSLT transformer.</p><p><b>Parameter <em class="replaceable"><code>$options</code></em>:&nbsp;</b>[optional argument] an element holding options in the form of attributes: see below.</p><p><b>Returned value:&nbsp;</b>if the path of an output file is not specified in the options, the function returns a new document tree which is the result of the transformation of the source tree. Otherwise, it returns the empty sequence.</p><div class="table"><a name="d0e9153"></a><p class="title"><b>Table&nbsp;11.2.&nbsp;XSLT transform options</b></p><div class="table-contents"><table summary="XSLT transform options" border="1"><colgroup><col width="33%" align="left"><col width="22%"><col width="45%"></colgroup><thead><tr><th align="left">option name</th><th align="left">values</th><th align="left">description</th></tr></thead><tbody><tr><td align="left">output-file</td><td>An absolute file path.</td><td>Output file. If this option is not specified, the generated tree is returned by the function, otherwise the function returns an empty sequence.</td></tr><tr><td align="left"><span class="emphasis"><em>XSLT output properties</em></span> (instruction xsl:output): version, standalone, encoding, indent, omit-xml-declaration etc.</td><td>&nbsp;</td><td>These options are used by the style-sheet for outputting the transformed document. They are ignored if no output-file option is specified.</td></tr><tr><td align="left">Specific options of the XSLT engine (Saxon or default XSLT engine)</td><td>&nbsp;</td><td>An invalid option may cause an error.</td></tr></tbody></table></div></div><br class="table-break"></dd></dl></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">About the efficiency of the connection with XSLT</h3><p>The connection with an XSLT engine uses generic JAXP interfaces, and thus must copy XML trees passed in both directions. This is not as efficient as it could be and can even cause memory problems if the size of processed documents is larger then a few dozen megabytes, depending on the available memory size.</p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e9195"></a>3.&nbsp;Dynamic evaluation</h2></div></div></div><p>The following functions allow dynamically compiling and executing XQuery expressions.</p><div class="variablelist"><dl><dt><span class="term"><a name="dyn-eval"></a><pre class="synopsis">function x:eval( <em class="replaceable"><code>$expression</code></em> as xs:string )
  as xs:any</pre></span></dt><dd><p>Compiles and evaluates a simple expression provided as a string.</p><p>The expression is executed in the context of the current query: it can use global variables, functions and namespaces of the current static context. It can also use the current item '.' if defined in the evaluation context.</p><p>However there is no access to the local context (for example if <code class="function">x:eval</code> is invoked inside a function, the arguments or the local variables of the function are not visible.)</p><p><b>Parameter <em class="replaceable"><code>$expression</code></em>:&nbsp;</b>a simple expression (cannot contain prologue declarations).</p><p><b>Returned value:&nbsp;</b>evaluated value of the expression.</p><p>Example:</p><pre class="programlisting">declare variable $x := 1;
declare function local:fun($p as xs:integer) { $p * 2 };

let $expr := "1 + $x, local:fun(3)"
return x:eval($expr)</pre><p>This should return the sequence <code class="literal">(2, 6)</code>.</p></dd></dl></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e9240"></a>4.&nbsp;Pattern-matching</h2></div></div></div><p>The following functions match the string-value of nodes (elements and attributes) with a pattern.</p><p>Example&nbsp;1: this expression returns true if the value of the attribute @lang matches the SQL-style pattern:</p><pre class="programlisting">x:like( "en%", $node/@lang )</pre><p>Example&nbsp;2: this expression returns true if the content of the element 'NAME' matches the pattern:</p><pre class="programlisting">$p/NAME[ x:like( "Theo%" ) ]</pre><div class="variablelist"><dl><dt><span class="term"><pre class="synopsis">function x:like( <em class="replaceable"><code>$pattern</code></em> as xs:string [, $context-nodes as node()* ])
  as xs:boolean</pre></span></dt><dd><p>Returns true if the pattern matches the string-value of at least one node in the node sequence argument.</p><p><b>Parameter <em class="replaceable"><code>$pattern</code></em>:&nbsp;</b>a SQL-style pattern: the wildcard '<code class="literal">_</code>' matches any single character, the wildcard '<code class="literal">%</code>' matches any sequence of characters.</p><p><b>Parameter <em class="replaceable"><code>$context-nodes</code></em>:&nbsp;</b>optional sequence of nodes. The function checks sequentially the string-value of each node against the pattern. If absent, the argument default to '<code class="literal">.</code>', the current item. This makes sense inside a predicate, like in the example 2 above.</p><p><b>Returned value:&nbsp;</b>a boolean.</p></dd><dt><span class="term"><pre class="synopsis">function x:ulike( <em class="replaceable"><code>$pattern</code></em> as xs:string [, <em class="replaceable"><code>$context-nodes</code></em> as node()* ])
  as xs:boolean</pre></span></dt><dd><p>This function is very similar to <code class="function">x:like</code>, except that the pattern has syntax &agrave; la Unix ("glob pattern"). The character '<code class="literal">?</code>' is used instead of '<code class="literal">_</code>' (single character match), and '<code class="literal">*</code>' instead of '<code class="literal">%</code>' (multi-character match).</p></dd></dl></div><p><span class="bold"><strong>Note</strong></span>: these functions &#8212; as well as the standard <code class="function">fn:matches</code> function, and the full-text functions &#8212; are automatically recognized by the query optimizer which uses library indexes to boost their execution whenever possible.</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e9329"></a>5.&nbsp;Date and Time</h2></div></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e9332"></a>5.1.&nbsp;Differences with W3C specifications</h3></div></div></div><p>Qizx is compliant with the W3C Recommendation. The only differences at present are extensions of the cast operation: Qizx can directly cast date, time, dateTime and durations to and from double values representing seconds, and keeps the extended "constructors" that build date, dateTime, etc, from numeric components like days, hours, minutes, etc.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e9337"></a>5.2.&nbsp;Cast Extensions</h3></div></div></div><p>In order to make computations easier, Qizx can:</p><div class="itemizedlist"><ul type="disc"><li><p>Cast <code class="literal">xdt:yearMonthDuration</code> to numeric values: this yields the number of months. The following expression returns 13:</p><pre class="programlisting">xdt:yearMonthDuration("P1Y1M") cast as xs:integer</pre></li><li><p>Conversely, cast numeric value representing months to <code class="literal">xdt:yearMonthDuration</code>. The following expression holds true:</p><pre class="programlisting">xdt:yearMonthDuration(13) = xdt:yearMonthDuration("P1Y1M")</pre></li><li><p>Cast <code class="literal">xdt:daytimeDuration</code> to double: this yields the number of seconds. The following expression returns 7201:</p><pre class="programlisting">xdt:dayTimeDuration("PT2H1S") cast as xs:double</pre></li><li><p>Conversely, cast a numeric value representing seconds to <code class="literal">xdt:daytimeDuration</code>.</p></li><li><p>Cast <code class="literal">xs:dateTime</code> to double. This returns the number of seconds elapsed since ``the Epoch'', i.e. 1970-01-01T00:00:00Z. If the timezone is not specified, it is considered to be UTC (GMT).</p></li><li><p>Conversely, cast a numeric value representing seconds from the origin to a dateTime with GMT timezone.</p></li><li><p>cast from/to the <code class="literal">xs:date</code> type in a similar way (like a dateTime with time equal to 00:00:00).</p><pre class="programlisting">xdt:date("1970-01-02") cast as xs:double = 86400</pre></li><li><p>cast from/to the <code class="literal">xs:time</code> type in a similar way (seconds from 00:00:00).</p><pre class="programlisting">xdt:time("01:00:00") cast as xs:double = 3600</pre></li></ul></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e9398"></a>5.3.&nbsp;Additional constructors</h3></div></div></div><p>These constructors allow date, time, dateTime objects to be built from numeric components (this is quite useful in practice).</p><div class="variablelist"><dl><dt><span class="term"><pre class="synopsis">function xs:date( <em class="replaceable"><code>$year</code></em> as xs:integer,
                  <em class="replaceable"><code>$month</code></em> as xs:integer,
                  <em class="replaceable"><code>$day</code></em> as xs:integer )
  as xs:date</pre></span></dt><dd><p>Builds a <code class="literal">xs:date</code> from a year, a month, and a day in integer form. The implicit timezone is used.</p><p>For example <code class="code">xs:date(1999, 12, 31)</code> returns the same value as <code class="code">xs:date("1999-12-31")</code>.</p></dd><dt><span class="term"><pre class="synopsis">function xs:time( <em class="replaceable"><code>$hour</code></em> as xs:integer,
                  <em class="replaceable"><code>$minute</code></em> as xs:integer,
                  <em class="replaceable"><code>$second</code></em> as xs:double )
  as xs:time</pre></span></dt><dd><p>Builds a <code class="literal">xs:time</code> from an hour, a minute as integer, and seconds as double. The implicit timezone is used.</p></dd><dt><span class="term"><pre class="synopsis">function xs:dateTime( <em class="replaceable"><code>$year</code></em> as xs:integer, <em class="replaceable"><code>$month</code></em> as xs:integer, <em class="replaceable"><code>$day</code></em> as xs:integer, 
                      <em class="replaceable"><code>$hour</code></em> as xs:integer, <em class="replaceable"><code>$minute</code></em> as xs:integer, <em class="replaceable"><code>$second</code></em> as xs:double 
                      [, <em class="replaceable"><code>$timezone</code></em> as xs:double] )
  as xs:dateTime</pre></span></dt><dd><p>Builds a <code class="literal">xs:dateTime</code> from the six components that constitute date and time.</p><p>A timezone can be specified: it is expressed as a signed number of hours (ranging from -14 to 14), otherwise the implicit timezone is used.</p></dd></dl></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e9483"></a>5.4.&nbsp;Additional accessors</h3></div></div></div><p>These functions are kept for compatibility. They are slightly different than the standard functions:</p><div class="itemizedlist"><ul type="disc"><li><p>they accept several date/time and durations types for the argument (so for example we have get-minutes instead of get-minutes-from-time, get-minutes-from-dateTime etc.),</p></li><li><p>but they do not accept untypedAtomic (node contents): such an argument should be cast to the proper type before being used. So the standard function might be as convenient here.</p></li></ul></div><div class="variablelist"><dl><dt><span class="term"><pre class="synopsis">function get-seconds( <em class="replaceable"><code>$moment</code></em> )
  as xs:double?</pre></span></dt><dd><p>Returns the "second" component from a xs:time, xs:dateTime, and xs:duration.</p><p>Can replace fn:seconds-from-dateTime, fn:seconds-from-time, fn:seconds-from-duration, except that the returned type is double instead of decimal, and an argument of type xdt:untypedAtomic is not valid.</p></dd><dt><span class="term"><pre class="synopsis">function get-all-seconds( <em class="replaceable"><code>$duration</code></em> )
  as xs:double?</pre></span></dt><dd><p>Returns the total number of seconds from a xs:duration. This does not take into account months and years, as explained above.</p><p>For example <code class="code">get-all-seconds(xs:duration("P1YT1H"))</code> returns 3600.</p></dd><dt><span class="term"><pre class="synopsis">function get-minutes( <em class="replaceable"><code>$moment</code></em> )
  as xs:integer?</pre></span></dt><dd><p>Returns the "minute" component from a <code class="literal">xs:time</code>, <code class="literal">xs:dateTime</code>, and <code class="literal">xs:duration</code>.</p></dd><dt><span class="term"><pre class="synopsis">function get-hours( <em class="replaceable"><code>$moment</code></em> )
  as xs:integer?</pre></span></dt><dd><p>Returns the "hour" component from a <code class="literal">xs:time</code>, <code class="literal">xs:dateTime</code>, and <code class="literal">xs:duration</code>.</p></dd><dt><span class="term"><pre class="synopsis">function get-days( <em class="replaceable"><code>$moment</code></em> )
  as xs:integer?</pre></span></dt><dd><p>Returns the "day" component from a <code class="literal">xs:date</code>, <code class="literal">xs:dateTime</code>, <code class="literal">xs:day</code>, <code class="literal">xs:monthDay</code> and <code class="literal">xs:duration</code>.</p></dd><dt><span class="term"><pre class="synopsis">function get-months( <em class="replaceable"><code>$moment</code></em> )
  as xs:integer?</pre></span></dt><dd><p>Returns the "month" component from a <code class="literal">xs:date</code>, <code class="literal">xs:dateTime</code>, <code class="literal">xs:yearMonth</code>, <code class="literal">xs:month</code>, <code class="literal">xs:monthDay</code> and <code class="literal">xs:duration</code>.</p></dd><dt><span class="term"><pre class="synopsis">function get-years( <em class="replaceable"><code>$moment</code></em> )
  as xs:integer?</pre></span></dt><dd><p>Returns the "year" component from a <code class="literal">xs:date</code>, <code class="literal">xs:dateTime</code>, <code class="literal">xs:year</code>, <code class="literal">xs:yearMonth</code> and <code class="literal">xs:duration</code>.</p></dd><dt><span class="term"><pre class="synopsis">function get-timezone( <em class="replaceable"><code>$moment</code></em> )
  as xs:duration?</pre></span></dt><dd><p>Returns the "timezone" component from any date/time type and <code class="literal">xs:duration</code>.</p><p>The returned value is like <code class="function">timezone-from-*</code> except that the returned type is <code class="literal">xs:duration</code>, not <code class="literal">xdt:dayTimeDuration</code>.</p></dd></dl></div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e9663"></a>6.&nbsp;Error handling</h2></div></div></div><p>XQuery has currently no mechanism to handle run-time errors.</p><p>Actually the language is such that an error handling is not absolutely mandatory: many errors need not be recovered (for example type errors); the <code class="function"><code class="classname">doc()</code></code> function which, can generate a dynamic error, is now protected by a new function <code class="function">doc-available()</code>.</p><p>However, extensions (namely the Java binding mechanism) can generate errors. It is not possible to provide a protection auxiliary like <code class="function">doc-available()</code> for every functionality.</p><p>Qizx provides a try/catch construct, which is a syntax extension. This construct has several purposes.</p><div class="variablelist"><dl><dt><span class="term"><pre class="synopsis">try { <code class="exceptionname"><em class="replaceable"><code>expr</code></em></code> } catch(<em class="replaceable"><code>$error</code></em>) { <em class="replaceable"><code>fallback-expr</code></em> }</pre></span></dt><dd><p>The try/catch extended language construct first evaluates the body <em class="replaceable"><code>expr</code></em>. If no error occurs, then the result of the try/catch is the return value of this expression.</p><p>If an error occurs, the local variable <em class="replaceable"><code>$error</code></em> receives a string value which is the error message, and <em class="replaceable"><code>fallback-expr</code></em> is evaluated (with possible access to the error message). The resulting value of the try/catch is in this case the value of this fallback expression. An error in the evaluation of the fallback-expression is not caught.</p><p>The type of this expression is the type that encompasses the types of both arguments.</p><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Important</h3><p>The body (first expression) is guaranteed to be evaluated completely before exiting the try/catch - unless an error occurs. In other terms, lazy evaluation, which is used in most Qizx expressions, does not apply here.</p><p>This is specially important when functions with side-effects are called in the body. If such functions generate errors, these errors are caught by the try/catch, as one can expect. Otherwise lazy evaluation could produce strange effects.</p></div><p>Example: tries to open a document, returns an element <code class="sgmltag-element">error</code> with an attribute <code class="sgmltag-attribute">msg</code> containing the error message if the document cannot be opened.</p><pre class="programlisting">try {
    doc("unreachable.xml")
}
catch($err) {
    &lt;error msg="{$err}"/&gt;
}</pre></dd></dl></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e9730"></a>7.&nbsp;Miscellaneous</h2></div></div></div><div class="variablelist"><dl><dt><span class="term"><pre class="synopsis">function x:parse($xml-text)
  as node()?</pre></span></dt><dd><p>Parses a string representing an XML document and returns a node built from that parsing. This can be useful for converting to a node a string from any origin.</p><p>Note that function x:eval could be used too (and it is more powerful, since any kind of node can be built with it), but there are some syntax differences: for example in x:eval, the curly braces <code class="code">{</code> and <code class="code">}</code> have to be escaped by duplicating them.</p><p><b>Parameter <em class="replaceable"><code>$xml-text</code></em>:&nbsp;</b>A well-formed XML document as a string.</p><p><b>Returned value:&nbsp;</b>A node of the Data Model if the string could be correctly parsed; the empty sequence if the argument was the empty sequence. An error is raised if there is a parsing error.</p></dd><dt><span class="term"><pre class="synopsis">function x:in-range( $value, $low-bound as item(), $high-bound as item() )
  as xs:boolean

function x:in-range( $value, $low-bound as item(), $high-bound as item(), 
                     $low-included as xs:boolean,
                     $high-included as xs:boolean )
  as xs:boolean</pre></span></dt><dd><p>Returns true if at least one item from the sequence <em class="replaceable"><code>$value</code></em> belongs to the range defined by other parameters.</p><p>This function is used typically to optimize a predicate in a Library query, for example <code class="code">//object[&nbsp;x:in-range(@weight,&nbsp;1,&nbsp;10)&nbsp;]</code> which is equivalent to <code class="code">//object[@weight&nbsp;&gt;=&nbsp;1&nbsp;and&nbsp;@weight&nbsp;&lt;=&nbsp;10]</code>.</p><p>The reason for this function is that the query optimizer is not able to detect such a double test in all situations. The function could become useless in later versions of Qizx, after improvement of the query optimizer.</p><p><b>Parameter <em class="replaceable"><code>$value</code></em>:&nbsp;</b>Any sequence of items. Items must be comparable to the bounds, otherwise a type error is raised.</p><p><b>Parameters <em class="replaceable"><code>$low-bound</code></em>, <em class="replaceable"><code>$high-bound</code></em>:&nbsp;</b>Lower and upper bounds of the range. They must be of compatible types.</p><p><b>Parameters <em class="replaceable"><code>$low-included</code></em>:&nbsp;</b>If <em class="replaceable"><code>$low-included</code></em> is equal to <code class="function">true()</code>, the comparison used is <code class="code">$low-bound&nbsp;&lt;=&nbsp;$value</code>, otherwise <code class="code">$low-bound&nbsp;&lt;&nbsp;$value</code>. If absent, <code class="code">&lt;=</code> is assumed.</p><p><b>Parameters <em class="replaceable"><code>$high-included</code></em>:&nbsp;</b>If <em class="replaceable"><code>$high-included</code></em> is equal to <code class="function">true()</code>, the comparison used is <code class="code">$value&nbsp;&lt;=&nbsp;$high-bound</code>, otherwise <code class="code">$value&nbsp;&lt;&nbsp;$high-bound</code>. If absent, <code class="code">&lt;=</code> is assumed.</p><p><b>Returned value:&nbsp;</b>True if at least one item from the sequence <em class="replaceable"><code>$value</code></em> belongs to the range defined by <em class="replaceable"><code>$low-bound</code></em>, <em class="replaceable"><code>$high-bound</code></em>.</p></dd></dl></div></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="reference.html">Prev</a>&nbsp;</td><td width="20%" align="center"><a accesskey="u" href="reference.html">Up</a></td><td width="40%" align="right">&nbsp;<a accesskey="n" href="fulltext_extensions.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Part&nbsp;IV.&nbsp;Reference&nbsp;</td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top">&nbsp;Chapter&nbsp;12.&nbsp;Full-text XQuery extension functions</td></tr></table></div></body></html>